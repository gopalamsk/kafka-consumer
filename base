package com.bns.fsl.emt.incoming.event.mapper;

import com.bns.fsl.domain.emt.*;
import com.bns.fsl.emt.incoming.event.exception.MappingException;
import com.bns.fsl.schema.rtp.aci.model.XFRqst;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Marshaller;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.mapstruct.*;

@Mapper(
    componentModel = MappingConstants.ComponentModel.SPRING,
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    builder = @Builder(disableBuilder = false),
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_NULL)
public interface BaseMapper {

  @Named("getXMLStringFromObject")
  static String getXMLStringFromObject(XFRqst acirqst) throws JAXBException {
    JAXBContext jaxbContext = JAXBContext.newInstance(XFRqst.class);
    Marshaller jaxbMarshaller = jaxbContext.createMarshaller();
    StringWriter sw = new StringWriter();
    jaxbMarshaller.marshal(acirqst, sw);
    return sw.toString();
  }

  @Named("getFormattedTranAmount")
  default BigDecimal getFormattedTranAmount(String amount) {
    DecimalFormat df = new DecimalFormat("#,##0.00");
    return Optional.ofNullable(amount)
        .map(
            amt -> {
              try {
                Number parsedNumber = df.parse(amt);
                String decimalString = df.format(parsedNumber).replace(",", "");
                return new BigDecimal(decimalString);
              } catch (ParseException e) {
                return null;
              }
            })
        .orElse(null);
  }

  @Named("getInterntnlInd")
  default String getInterntnlInd(String productCode) {
    return "DOMESTIC".equals(productCode) ? "0" : "INTERNATIONAL".equals(productCode) ? "1" : "";
  }

  @Named("getDebtCountryCode")
  default String getDebtCountryCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(), payment.getDebtor(), Address::getCountryCode);
  }

  @Named("getCreditCountryCode")
  default String getCreditCountryCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(), payment.getCreditor(), Address::getCountryCode);
  }

  @Named("getCreditorName")
  default String getCreditorName(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(payment.getUltimateCreditor(), payment.getCreditor(), Party::getName);
  }

  @Named("getdebitorName")
  default String getdebitorName(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(payment.getUltimateDebtor(), payment.getDebtor(), Party::getName);
  }

  @Named("getDebitorPostalCode")
  default String getDebitorPostalCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(), payment.getDebtor(), Address::getPostalCode);
  }

  @Named("getCreditorPostalCode")
  default String getCreditorPostalCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(), payment.getCreditor(), Address::getPostalCode);
  }

  @Named("getOrigWireAcctAdr1")
  default String getOrigWireAcctAdr1(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(),
        payment.getDebtor(),
        addr -> joinStrings(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("getOrigWireAcctAdr2")
  default String getOrigWireAcctAdr2(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(),
        payment.getDebtor(),
        addr ->
            joinStrings(
                " ",
                addr.getCity(),
                addr.getStateProvince(),
                addr.getPostalCode(),
                addr.getCountryCode()));
  }

  @Named("getbenWireAccthldrAdr1")
  default String getbenWireAccthldrAdr1(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(),
        payment.getCreditor(),
        addr -> joinStrings(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("appendErrorCodeDesc")
  default String appendErrorCodeDesc(Payment payment) {
    if (payment == null) return null;

    String code = payment.getErrorCode();
    String desc = payment.getErrorDesc();

    return (code == null ? "" : code) + ";" + (desc == null ? "" : desc);
  }

  @Named("getbenWireAccthldrAdr2")
  default String getbenWireAccthldrAdr2(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(),
        payment.getCreditor(),
        addr ->
            joinStrings(
                " ",
                addr.getCity(),
                addr.getStateProvince(),
                addr.getPostalCode(),
                addr.getCountryCode()));
  }

  @Named("getCreditorEmailid")
  default String getCreditorEmailid(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(
        payment.getUltimateCreditor(),
        payment.getCreditor(),
        party ->
            Optional.ofNullable(firstContact(party))
                .map(Contact::getEmail)
                .map(Email::getEmailId)
                .orElse(null));
  }

  @Named("getRespCode")
  default String getRespCode(String status) {
    return "SUCCESS".equals(status) ? "01" : "FAILED".equals(status) ? "50" : null;
  }

  @Named("firstPhoneNum")
  static String firstPhoneNum(List<Contact> contacts) {
    return java.util.Optional.ofNullable(contacts).stream()
        .flatMap(List::stream)
        .filter(Objects::nonNull)
        .map(Contact::getMobile)
        .filter(Objects::nonNull)
        .map(Phone::getPhoneNum)
        .filter(s -> s != null && !s.isBlank())
        .findFirst()
        .orElse(null);
  }

  @Named("getInstructionForCreditorAgent")
  default String getInstructionForCreditorAgent(List<InstructionForCreditorAgent> sourceList) {
    if (sourceList == null || sourceList.isEmpty()) {
      return null;
    }

    String result =
        sourceList.stream()
            .map(src -> joinStrings(" ", src.getCode(), src.getInstructionInformation()))
            .filter(str -> str != null && !str.isBlank()) // Skip empty agents
            .collect(Collectors.joining(" "));

    return result.isBlank() ? null : result;
  }

  @Named("getFraudScores")
  default String getFraudScores(SupplementaryScores scores) {
    if (scores == null) return null;

    return joinStrings(
        "; ",
        formatScoring(
            scores.getAdditionalProp1(),
            AdditionalProp1::getScore,
            AdditionalProp1::getReasonCodes),
        formatScoring(
            scores.getAdditionalProp2(),
            AdditionalProp2::getScore,
            AdditionalProp2::getReasonCodes),
        formatScoring(
            scores.getAdditionalProp3(),
            AdditionalProp3::getScore,
            AdditionalProp3::getReasonCodes));
  }

  @Named("first6Digits")
  public static String first6Digits(String cardNumber) {
    if (cardNumber == null) return null;
    String formatted = cardNumber.replaceAll("[^0-9]", ""); // removes extra soaces, dashes
    return formatted.length() >= 6 ? formatted.substring(0, 6) : null;
  }

  default <T> String formatScoring(
      T obj, Function<T, String> scoreFunc, Function<T, String> reasonFunc) {
    if (obj == null) return null;

    String score = scoreFunc.apply(obj);
    String reason = reasonFunc.apply(obj);

    return joinStrings(":", score, reason);
  }

  default String joinStrings(String delimiter, String... fields) {
    if (fields == null) return null;
    String result =
        Stream.of(fields)
            .filter(s -> s != null && !s.isBlank())
            .collect(Collectors.joining(delimiter));
    return result.isBlank() ? null : result;
  }

  default String resolveAddressField(
      Party ultimate, Party normal, Function<Address, String> fieldExtractor) {
    return getRequiredField(firstAddress(ultimate), firstAddress(normal), fieldExtractor);
  }

  default <P> String getRequiredField(P ultimate, P normal, Function<P, String> extractor) {
    return Optional.ofNullable(ultimate)
        .map(extractor)
        .filter(s -> !s.isBlank())
        .orElseGet(
            () ->
                Optional.ofNullable(normal).map(extractor).filter(s -> !s.isBlank()).orElse(null));
  }

  default Address firstAddress(Party p) {
    return Optional.ofNullable(p)
        .map(Party::getAddresses)
        .filter(list -> !list.isEmpty())
        .map(list -> list.get(0))
        .orElse(null);
  }

  default Contact firstContact(Party p) {
    return Optional.ofNullable(p)
        .map(Party::getContacts)
        .filter(list -> !list.isEmpty())
        .map(list -> list.get(0))
        .orElse(null);
  }

  XFRqst mapACIRequest(FslIncomingPaymentEventsRequest fslIncomingPaymentEventsRequest)
      throws MappingException;
}
