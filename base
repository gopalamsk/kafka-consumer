package com.bns.fsl.emt.incoming.event.mapper;

import com.bns.fsl.domain.emt.*;
import com.bns.fsl.emt.incoming.event.exception.MappingException;
import com.bns.fsl.schema.rtp.aci.model.XFRqst;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Marshaller;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.mapstruct.*;

@Mapper(
    componentModel = MappingConstants.ComponentModel.SPRING,
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    builder = @Builder(disableBuilder = false),
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_NULL)
public interface BaseMapper {

  // ========================================================================
  // NEW: Composite & Concatenated Mappings
  // ========================================================================

  /**
   * Resolves email from the first contact in the list.
   * Path: Party -> List<Contact> (get 0) -> Email -> EmailId


// ========================================================================
  // FRAUD SCORES (Compact Format)
  // ========================================================================

  /**
   * Maps SupplementaryScores to compact string: "5:BEHAVIORAL_OK; 3:DEVICE_TRUSTED"
   */
  @Named("getFraudScores")
  default String getFraudScores(SupplementaryScores scores) {
    if (scores == null) return null;

    // We join the results with "; " (Semicolon + Space)
    return joinFields("; ",
        formatCompactPair(scores.getAdditionalProp1(), AdditionalProp1::getScore, AdditionalProp1::getReasonCodes),
        formatCompactPair(scores.getAdditionalProp2(), AdditionalProp2::getScore, AdditionalProp2::getReasonCodes),
        formatCompactPair(scores.getAdditionalProp3(), AdditionalProp3::getScore, AdditionalProp3::getReasonCodes)
    );
  }

  /**
   * Helper: Extracts Score and Reason and joins them with ":"
   * Returns null if the property object is null.
   * If one field is missing, it returns just the available one (e.g., "5" or "REASON").
   */
  default <T> String formatCompactPair(T obj, Function<T, String> scoreFunc, Function<T, String> reasonFunc) {
    if (obj == null) return null;

    String score = scoreFunc.apply(obj);
    String reason = reasonFunc.apply(obj);

    // joinFields handles nulls automatically. 
    // If both exist: "5:BEHAVIORAL_OK"
    // If only score: "5"
    return joinFields(":", score, reason);
  }
   */
  @Named("getCreditorEmailId")
  default String getCreditorEmailId(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(
        payment.getUltimateCreditor(),
        payment.getCreditor(),
        party -> Optional.ofNullable(firstContact(party))
            .map(Contact::getEmail)
            .map(Email::getEmailId)
            .orElse(null));
  }

@Named("getDebtorFullAddress")
  default String getDebtorFullAddress(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(payment.getUltimateDebtor(), payment.getDebtor(), addr -> 
        joinNonEmpty(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("getDebtorCityStateZip")
  default String getDebtorCityStateZip(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(payment.getUltimateDebtor(), payment.getDebtor(), addr -> 
        joinNonEmpty(" ", addr.getCity(), addr.getStateProvince(), addr.getPostalCode(), addr.getCountryCode()));
  }

  @Named("getCreditorFullAddress")
  default String getCreditorFullAddress(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(payment.getUltimateCreditor(), payment.getCreditor(), addr -> 
        joinNonEmpty(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("getCreditorCityStateZip")
  default String getCreditorCityStateZip(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(payment.getUltimateCreditor(), payment.getCreditor(), addr -> 
        joinNonEmpty(" ", addr.getCity(), addr.getStateProvince(), addr.getPostalCode(), addr.getCountryCode()));
  }

@Named("getInstructionForCreditorAgent")
  default String getInstructionForCreditorAgent(List<InstructionForCreditorAgent> sourceList) {
    if (sourceList == null || sourceList.isEmpty()) {
      return null;
    }
    // Stream the list, format each item, and join them with spaces
    String result = sourceList.stream()
        .map(src -> joinFields(" ", src.getCode(), src.getInstructionInformation()))
        .filter(str -> str != null && !str.isBlank()) // Skip empty agents
        .collect(Collectors.joining(" "));

    return result.isBlank() ? null : result;
  }

  @Named("getDebtorAddressLine")
  default String getDebtorAddressLine(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(), 
        payment.getDebtor(), 
        addr -> joinFields(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("getDebtorLocation")
  default String getDebtorLocation(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(), 
        payment.getDebtor(), 
        addr -> joinFields(" ", addr.getCity(), addr.getStateProvince(), addr.getPostalCode(), addr.getCountryCode()));
  }

  @Named("getCreditorAddressLine")
  default String getCreditorAddressLine(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(), 
        payment.getCreditor(), 
        addr -> joinFields(" ", addr.getAdr1(), addr.getAdr2(), addr.getAdr3()));
  }

  @Named("getCreditorLocation")
  default String getCreditorLocation(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(), 
        payment.getCreditor(), 
        addr -> joinFields(" ", addr.getCity(), addr.getStateProvince(), addr.getPostalCode(), addr.getCountryCode()));
  }

  // ========================================================================
  // Existing Single-Field Mappings
  // ========================================================================

  @Named("getDebtCountryCode")
  default String getDebtCountryCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateDebtor(), payment.getDebtor(), Address::getCountryCode);
  }

  @Named("getCreditCountryCode")
  default String getCreditCountryCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(
        payment.getUltimateCreditor(), payment.getCreditor(), Address::getCountryCode);
  }

  @Named("getCreditorName")
  default String getCreditorName(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(payment.getUltimateCreditor(), payment.getCreditor(), Party::getName);
  }

  @Named("getdebitorName")
  default String getdebitorName(Payment payment) {
    if (payment == null) return null;
    return getRequiredField(payment.getUltimateDebtor(), payment.getDebtor(), Party::getName);
  }

  @Named("getdebitorPostalCode")
  default String getdebitorPostalCode(Payment payment) {
    if (payment == null) return null;
    return resolveAddressField(payment.getUltimateDebtor(), payment.getDebtor(), Address::getPostalCode);
  }

  @Named("getInterntnlInd")
  default String getInterntnlInd(String productCode) {
    return "DOMESTIC".equals(productCode) ? "0" : "INTERNATIONAL".equals(productCode) ? "1" : "";
  }

  @Named("getFormattedTranAmount")
  default BigDecimal getFormattedTranAmount(String amount) {
    DecimalFormat df = new DecimalFormat("#,##0.00");
    return Optional.ofNullable(amount)
        .map(amt -> {
              try {
                Number parsedNumber = df.parse(amt);
                String decimalString = df.format(parsedNumber).replace(",", "");
                return new BigDecimal(decimalString);
              } catch (ParseException e) {
                return null;
              }
            })
        .orElse(null);
  }

  @Named("getXMLStringFromObject")
  static String getXMLStringFromObject(XFRqst acirqst) throws JAXBException {
    JAXBContext jaxbContext = JAXBContext.newInstance(XFRqst.class);
    Marshaller jaxbMarshaller = jaxbContext.createMarshaller();
    StringWriter sw = new StringWriter();
    jaxbMarshaller.marshal(acirqst, sw);
    return sw.toString();
  }

  XFRqst mapACIRequest(FslIncomingPaymentEventsRequest fslIncomingPaymentEventsRequest)
      throws MappingException;

  // ========================================================================
  // Core Helper Methods (The "Engine" of the Mapper)
  // ========================================================================

  /**
   * Joins multiple strings with the specified delimiter.
   * Skips nulls and blank strings.
   * Returns null if the result is empty (triggering fallback logic).
   */
  default String joinFields(String delimiter, String... fields) {
    if (fields == null) return null;
    String result = Stream.of(fields)
        .filter(s -> s != null && !s.isBlank())
        .collect(Collectors.joining(delimiter));
    return result.isBlank() ? null : result;
  }

  /**
   * Resolves a field from an Address object, respecting the Ultimate > Normal priority.
   */
  default String resolveAddressField(
      Party ultimate, Party normal, Function<Address, String> fieldExtractor) {
    return getRequiredField(firstAddress(ultimate), firstAddress(normal), fieldExtractor);
  }

  /**
   * Generic resolver: Tries the Ultimate object first; if the result is null/blank, tries Normal.
   */
  default <P> String getRequiredField(P ultimate, P normal, Function<P, String> extractor) {
    return Optional.ofNullable(ultimate)
        .map(extractor)
        .filter(s -> !s.isBlank()) // Ensures we don't return " " from Ultimate
        .orElseGet(
            () ->
                Optional.ofNullable(normal)
                    .map(extractor)
                    .filter(s -> !s.isBlank())
                    .orElse(null));
  }

  /**
   * Safely retrieves the first address from the list.
   */
  default Address firstAddress(Party p) {
    return Optional.ofNullable(p)
        .map(Party::getAddresses)
        .filter(list -> !list.isEmpty())
        .map(list -> list.get(0))
        .orElse(null);
  }

  /**
   * Safely retrieves the first contact from the list.
   */
  default Contact firstContact(Party p) {
    return Optional.ofNullable(p)
        .map(Party::getContacts)
        .filter(list -> !list.isEmpty())
        .map(list -> list.get(0))
        .orElse(null);
  }
}
