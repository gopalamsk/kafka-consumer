package com.bns.fsl.emt.incoming.event.processor;

import com.bns.fsl.domain.emt.FslIncomingPaymentEventsRequest;
import com.bns.fsl.emt.incoming.event.util.CommonUtil;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.micrometer.observation.Observation;
import io.micrometer.observation.ObservationRegistry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.slf4j.MDC;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PayhubEventKafkaListener {

    private final PayhubEventProcessor payhubEventProcessor;
    private final ObjectMapper objectMapper;        // Standard Spring-managed ObjectMapper
    private final ObservationRegistry observationRegistry; // Micrometer Observation (replaces custom Aspect)

    // Key used in logs: [requestId=...]
    private static final String MDC_REQUEST_ID = "requestId";

    @KafkaListener(
        topics = "${app.kafka.topics.payhub-event}", 
        groupId = "${app.kafka.consumer.group-id}",
        containerFactory = "payhubContainerFactory" // Must be configured for AckMode.MANUAL_IMMEDIATE
    )
    public void consumePayhubEvent(ConsumerRecord<String, String> record, Acknowledgment acknowledgment) {
        String payload = record.value();

        // 1. Guard Clause: Skip empty messages immediately
        if (payload == null || payload.isBlank()) {
            log.warn("Skipping invalid empty message. Topic: {}, Partition: {}, Offset: {}", 
                     record.topic(), record.partition(), record.offset());
            acknowledgment.acknowledge();
            return;
        }

        // 2. Observability Block
        // This handles metrics (timer), tracing (spanId/traceId), and error counting automatically.
        Observation.createNotStarted("kafka.consume.payhub", observationRegistry)
                .lowCardinalityKeyValue("topic", record.topic())
                .observe(() -> {
                    try {
                        processMessage(payload);
                        acknowledgment.acknowledge(); // ‚úÖ Success: Commit offset
                    } catch (JsonProcessingException e) {
                        // üõë FATAL ERROR (Poison Pill)
                        // Malformed JSON cannot be retried. We MUST acknowledge to skip it 
                        // and unblock the partition.
                        log.error("POISON PILL DETECTED: Skipping invalid JSON payload. Offset: {}", record.offset(), e);
                        acknowledgment.acknowledge(); 
                    } catch (Exception e) {
                        // ‚ö†Ô∏è RETRYABLE ERROR (DB down, Network, etc.)
                        // Throwing exception triggers Spring Kafka's Backoff/Retry policy.
                        log.error("Transient error processing Payhub event. Retrying...", e);
                        throw new RuntimeException("Retryable error processing Kafka message", e); 
                    }
                });
    }

    private void processMessage(String payload) throws JsonProcessingException {
        // 3. Deserialize using the global ObjectMapper
        FslIncomingPaymentEventsRequest request = objectMapper.readValue(payload, FslIncomingPaymentEventsRequest.class);

        // 4. Extract Request ID safely
        String requestId = CommonUtil.extractRequestId(request).orElse("UNKNOWN");
        
        // 5. MDC Contextual Logging
        // Puts requestId into MDC. 'try-with-resources' ensures it is removed automatically 
        // when the block finishes, preventing thread-local leaks.
        try (var ignored = MDC.putCloseable(MDC_REQUEST_ID, requestId)) {
            log.info("Processing Payhub event started.");
            
            // Invoke Business Logic
            payhubEventProcessor.processPayhubEvent(request, requestId);
            
            log.info("Processing Payhub event completed successfully.");
        }
    }
}




package com.bns.fsl.emt.incoming.event.util;

import com.bns.fsl.domain.emt.FslIncomingPaymentEventsRequest;
// ... (Add other domain imports here: Payload, Paymentblock)
import java.util.Optional;

public final class CommonUtil {
    
    private CommonUtil() {
        // Prevent instantiation
    }

    public static Optional<String> extractRequestId(FslIncomingPaymentEventsRequest request) {
        return Optional.ofNullable(request)
                .map(FslIncomingPaymentEventsRequest::getPayload)
                .map(Payload::getPaymentblock) // Ensure getPaymentblock() matches your actual getter name
                .map(Paymentblock::getRequestId);
    }
}
